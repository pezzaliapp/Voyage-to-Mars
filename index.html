<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,viewport-fit=cover">
<title>Voyage to Mars — NASA-Style Flight (Single File)</title>
<style>
  :root{
    --bg:#030616; --ink:#eaf1ff; --muted:#91a2d8; --accent:#4dd0ff; --good:#6ee7b7; --warn:#fbbf24;
  }
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% -10%,#0b1231 0%,#070b22 40%,#030616 100%);color:var(--ink);font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #wrap{position:fixed;inset:0;overflow:hidden}
  canvas{position:absolute;inset:0;display:block}
  /* HUD */
  #hud{
    position:absolute;left:12px;top:12px;min-width:260px;max-width:46vw;
    background:rgba(10,14,32,.55);backdrop-filter: blur(6px);
    border:1px solid rgba(100,120,200,.25);border-radius:14px;padding:10px 12px 8px;
    box-shadow:0 10px 30px rgba(0,0,0,.35)
  }
  #hud h1{margin:0 0 6px;font-weight:700;font-size:16px;letter-spacing:.3px}
  #stats{display:grid;grid-template-columns:auto 1fr;gap:4px 10px;font-feature-settings:"tnum" 1,"lnum" 1}
  #stats b{color:var(--muted);font-weight:600}
  #bar{height:6px;background:rgba(255,255,255,.08);border-radius:99px;margin-top:8px;overflow:hidden}
  #bar span{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#9a7bff);width:0%}
  /* Controls */
  #controls{
    position:absolute;right:12px;bottom:12px;display:flex;gap:8px;flex-wrap:wrap;
    background:rgba(10,14,32,.55);backdrop-filter: blur(6px);
    border:1px solid rgba(100,120,200,.25);border-radius:14px;padding:8px
  }
  .btn{
    appearance:none;border:1px solid rgba(140,160,220,.35);background:rgba(18,24,60,.6);color:var(--ink);
    padding:8px 10px;border-radius:12px;cursor:pointer;transition:.15s;user-select:none;font-weight:600
  }
  .btn:hover{transform:translateY(-1px)}
  .btn:active{transform:translateY(0)}
  .btn.primary{background:linear-gradient(180deg,#1b2a6d,#121a4a);border-color:#4051a8}
  .badge{
    position:absolute;right:12px;top:12px;font-weight:700;color:#fff;background:#e11d48;border-radius:999px;
    padding:6px 10px;box-shadow:0 8px 30px rgba(225,29,72,.3)
  }
  /* Labels */
  .label{
    position:absolute;transform:translate(-50%,-50%);padding:4px 8px;border-radius:10px;
    background:rgba(10,14,32,.7);border:1px solid rgba(140,160,220,.35);color:#dfe7ff;font-size:12px;pointer-events:none
  }
  /* Tip */
  #tip{
    position:absolute;left:50%;bottom:10px;transform:translateX(-50%);
    color:#cbd5ff;font-size:12px;opacity:.8;user-select:none
  }
</style>
</head>
<body>
<div id="wrap">
  <canvas id="view"></canvas>
  <div id="hud">
    <h1>Voyage to Mars <span style="opacity:.6">— Missione dimostrativa</span></h1>
    <div id="stats">
      <b>Fase</b><span id="phase">Pre-launch</span>
      <b>Distanza a Marte</b><span id="dist">—</span>
      <b>Velocità</b><span id="vel">—</span>
      <b>Modalità</b><span id="mode">Camera AUTO</span>
    </div>
    <div id="bar"><span id="prog"></span></div>
  </div>
  <div id="controls">
    <button class="btn primary" id="btnPlay">⏯ Play/Pausa</button>
    <button class="btn" id="btnSpeedDown">– Speed</button>
    <button class="btn" id="btnSpeedUp">+ Speed</button>
    <button class="btn" id="btnMode">Camera</button>
    <button class="btn" id="btnRestart">Restart</button>
  </div>
  <div id="tip">Doppio clic: HUD ON/OFF — Trascina per ruotare in <b>Camera LIBERA</b> — Tasti: <b>Space</b>, <b>+</b>, <b>–</b>, <b>R</b>, <b>C</b></div>
  <div id="badge" class="badge" style="display:none">PAUSA</div>
  <!-- dynamic labels -->
  <div id="labels"></div>
</div>

<script>
(()=>{'use strict';

const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
let W=0,H=0, DPR=Math.min(2, window.devicePixelRatio||1);

function resize(){
  W = canvas.width = Math.floor(window.innerWidth * DPR);
  H = canvas.height = Math.floor((window.innerHeight) * DPR);
  canvas.style.width = window.innerWidth + 'px';
  canvas.style.height = window.innerHeight + 'px';
}
addEventListener('resize', resize, {passive:true}); resize();

/* ===== Utilities ===== */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
const ease = t=>t<.5? 4*t*t*t : 1 - Math.pow(-2*t+2,3)/2; // cubic in/out
const TAU = Math.PI*2;

function hsl(h,s,l,a=1){ return `hsla(${h} ${s}% ${l}% / ${a})`; }

/* ===== Simple 3D camera & projection ===== */
const cam = { x:0, y:0.25, z:2.8, rx:0, ry:0, mode:'AUTO' }; // ry: yaw, rx: pitch
function rotateY(v, a){
  const {x,z}=v; const ca=Math.cos(a), sa=Math.sin(a);
  return {...v, x:x*ca - z*sa, z:x*sa + z*ca};
}
function rotateX(v, a){
  const {y,z}=v; const ca=Math.cos(a), sa=Math.sin(a);
  return {...v, y:y*ca - z*sa, z:y*sa + z*ca};
}
function worldToScreen(p){
  // camera transform
  let v = {x:p.x - cam.x, y:p.y - cam.y, z:p.z - cam.z};
  v = rotateY(v, -cam.ry);
  v = rotateX(v, -cam.rx);
  const fov = 1.2; // smaller = zoom in
  const z = v.z <= 0.01 ? 0.01 : v.z;
  const sx = (v.x / (z * fov)) * (W/2) + W/2;
  const sy = (v.y / (z * fov)) * (W/2) + H/2; // use W for square pixels scaling
  const s = 1 / (z * fov);
  return {x:sx, y:sy, scale:s, z};
}

/* ===== Starfield ===== */
const stars = [];
function initStars(){
  stars.length=0;
  for(let i=0;i<800;i++){
    const r = 30 + Math.random()*120; // radius of sphere shell
    // random direction
    const u = Math.random()*TAU, v = Math.acos(2*Math.random()-1);
    const x = r*Math.sin(v)*Math.cos(u);
    const y = r*Math.cos(v);
    const z = r*Math.sin(v)*Math.sin(u);
    const mag = Math.random();
    stars.push({x,y,z,mag});
  }
}
initStars();

/* ===== Mission waypoints (in arbitrary units) =====
   path goes: Earth(0) -> Moon -> Jupiter -> Neptune -> Mars */
const WAYPOINTS = [
  { name:'Earth',   p:{x:0,    y:0, z:0},     r:0.18, color:[220,90,64], type:'planet' },
  { name:'Moon',    p:{x:0.6,  y:0.02, z:-0.4}, r:0.05, color:[220,20,85], type:'moon' },
  { name:'Jupiter', p:{x:5.5,  y:-0.2, z:-3.0}, r:0.35, color:[30,60,65],  type:'planet' },
  { name:'Neptune', p:{x:9.0,  y:0.4, z:-5.0},  r:0.28, color:[210,70,60], type:'planet', rings:true },
  { name:'Mars',    p:{x:12.0, y:0.05,z:-7.0},  r:0.16, color:[10,65,60],  type:'planet' },
];

const PHASES = [
  {label:'Orbita Terrestre',      t0:0.00, t1:0.18},
  {label:'Luna — fly-by',         t0:0.18, t1:0.32},
  {label:'Cruise verso Giove',    t0:0.32, t1:0.58},
  {label:'Giove — fly-by',        t0:0.58, t1:0.68},
  {label:'Cruise verso Nettuno',  t0:0.68, t1:0.86},
  {label:'Nettuno & anelli',      t0:0.86, t1:0.93},
  {label:'Inserzione su Marte',   t0:0.93, t1:1.00}
];

/* Build a smooth spline-like path through waypoints */
function samplePath(t){
  // map t in [0,1] to segment between waypoints
  const n = WAYPOINTS.length;
  const seg = Math.min(n-2, Math.floor(t*(n-1)));
  const lt = t*(n-1)-seg;
  // Catmull-Rom like using nearby points
  const p0 = WAYPOINTS[Math.max(0, seg-1)].p;
  const p1 = WAYPOINTS[seg].p;
  const p2 = WAYPOINTS[seg+1].p;
  const p3 = WAYPOINTS[Math.min(n-1, seg+2)].p;

  const tt = ease(lt);
  function interp(a,b,c,d,t){
    const t2 = t*t, t3 = t2*t;
    return 0.5*((2*b) + (-a + c)*t + (2*a-5*b+4*c - d)*t2 + (-a+3*b-3*c+d)*t3);
  }
  return {
    x: interp(p0.x,p1.x,p2.x,p3.x,tt),
    y: interp(p0.y,p1.y,p2.y,p3.y,tt),
    z: interp(p0.z,p1.z,p2.z,p3.z,tt),
  };
}

/* ===== Planet rendering (shaded discs + optional rings) ===== */
function drawPlanet(p, radius, hue, sat, light, rings=false, ringTilt=0.6){
  const S = worldToScreen(p);
  if(S.z<=0) return;
  const R = radius * S.scale * W; // screen radius

  // soft discard if too small
  if(R<2) return;

  // body
  const g = ctx.createRadialGradient(S.x-R*0.35, S.y-R*0.35, R*0.1, S.x, S.y, R);
  g.addColorStop(0, hsl(hue, sat, Math.min(96, light+18), 0.95));
  g.addColorStop(0.5, hsl(hue, sat, light, 0.95));
  g.addColorStop(1, hsl(hue, sat, Math.max(8, light-26), 0.95));

  ctx.beginPath();
  ctx.arc(S.x, S.y, R, 0, TAU);
  ctx.fillStyle = g;
  ctx.fill();

  // subtle bands for Jupiter/Neptune
  if(hue<60 || hue>180){
    const bands = 8;
    ctx.globalAlpha = 0.08;
    ctx.beginPath();
    for(let i=0;i<=bands;i++){
      const yy = S.y + (i/bands*2-1)*R*0.9;
      ctx.moveTo(S.x - Math.sqrt(Math.max(0,R*R - (yy-S.y)*(yy-S.y))), yy);
      ctx.lineTo(S.x + Math.sqrt(Math.max(0,R*R - (yy-S.y)*(yy-S.y))), yy);
    }
    ctx.strokeStyle = '#000'; ctx.lineWidth = 1; ctx.stroke();
    ctx.globalAlpha = 1;
  }

  // rings (elliptical, tilted)
  if(rings){
    const a = R*1.9, b = R*0.55; // axes
    ctx.save();
    ctx.translate(S.x, S.y);
    ctx.rotate(ringTilt);
    // back half
    ctx.globalAlpha=.35;
    ctx.beginPath();
    ctx.ellipse(0,0,a,b,0,Math.PI,0,true);
    ctx.lineWidth=R*0.28;
    ctx.strokeStyle='rgba(220,230,255,0.25)';
    ctx.stroke();
    ctx.globalAlpha=1;
    // planet redraw front clip
    ctx.beginPath();
    ctx.arc(0,0,R,0,TAU);
    ctx.clip();
    // front half rings
    ctx.globalAlpha=.6;
    ctx.beginPath();
    ctx.ellipse(0,0,a,b,0,0,Math.PI);
    ctx.lineWidth=R*0.28;
    ctx.strokeStyle='rgba(245,250,255,0.55)';
    ctx.stroke();
    ctx.restore();
  }

  // return screen pos for labels
  return {x:S.x, y:S.y, r:R};
}

/* ===== Labels (DOM) ===== */
const labelsHost = document.getElementById('labels');
const domLabels = new Map();
function setLabel(name, x,y){
  let el = domLabels.get(name);
  if(!el){
    el = document.createElement('div');
    el.className='label';
    el.textContent = name;
    labelsHost.appendChild(el);
    domLabels.set(name, el);
  }
  el.style.left = Math.round(x/DPR) + 'px';
  el.style.top  = Math.round(y/DPR - 18) + 'px';
}
function hideUnusedLabels(setUsed){
  for(const [name, el] of domLabels){
    if(!setUsed.has(name)) el.style.display='none';
    else el.style.display='';
  }
}

/* ===== UI elements ===== */
const elPhase = document.getElementById('phase');
const elDist  = document.getElementById('dist');
const elVel   = document.getElementById('vel');
const elMode  = document.getElementById('mode');
const elProg  = document.getElementById('prog');
const elBadge = document.getElementById('badge');

const btnPlay = document.getElementById('btnPlay');
const btnDown = document.getElementById('btnSpeedDown');
const btnUp   = document.getElementById('btnSpeedUp');
const btnMode = document.getElementById('btnMode');
const btnRe   = document.getElementById('btnRestart');

/* ===== Interaction ===== */
let running = true;
let speed = 0.08; // base time speed per second
let t = 0; // 0..1 along path
let yawDrag=0, pitchDrag=0, dragging=false, dragX=0, dragY=0;

function toggleRun(){ running = !running; elBadge.style.display = running?'none':''; }
function restart(){ t=0; running=true; }
function changeMode(){
  cam.mode = cam.mode==='AUTO' ? 'FREE' : 'AUTO';
  elMode.textContent = cam.mode==='AUTO' ? 'Camera AUTO' : 'Camera LIBERA';
}

/* Keyboard */
addEventListener('keydown', (e)=>{
  if(e.key===' '){ e.preventDefault(); toggleRun(); }
  if(e.key==='r' || e.key==='R') restart();
  if(e.key==='c' || e.key==='C') changeMode();
  if(e.key==='+' || e.key==='=' ) speed = Math.min(0.6, speed*1.25);
  if(e.key==='-' || e.key==='_' ) speed = Math.max(0.01, speed/1.25);
});
/* Mouse/touch drag */
function onDown(x,y){ if(cam.mode==='FREE'){ dragging=true; dragX=x; dragY=y; } }
function onMove(x,y){
  if(dragging){
    yawDrag += (x-dragX)*0.004;
    pitchDrag += (y-dragY)*0.004;
    dragX=x; dragY=y;
  }
}
function onUp(){ dragging=false; }
canvas.addEventListener('mousedown', e=>onDown(e.clientX,e.clientY));
addEventListener('mousemove', e=>onMove(e.clientX,e.clientY));
addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', e=>{const t=e.changedTouches[0]; onDown(t.clientX,t.clientY);},{passive:true});
canvas.addEventListener('touchmove', e=>{const t=e.changedTouches[0]; onMove(t.clientX,t.clientY);},{passive:true});
canvas.addEventListener('touchend', onUp, {passive:true});

/* Buttons */
btnPlay.onclick = toggleRun;
btnDown.onclick = ()=>speed = Math.max(0.01, speed/1.25);
btnUp.onclick   = ()=>speed = Math.min(0.6, speed*1.25);
btnMode.onclick = changeMode;
btnRe.onclick   = restart;
/* HUD toggle */
addEventListener('dblclick', ()=>{
  const hud = document.getElementById('hud');
  hud.style.display = hud.style.display==='none' ? '' : 'none';
});

/* ===== Phase text ===== */
function phaseFor(t){
  for(const p of PHASES){ if(t>=p.t0 && t<p.t1) return p.label; }
  return PHASES[PHASES.length-1].label;
}

/* ===== Main loop ===== */
let last = performance.now();
function tick(now){
  const dt = Math.min(0.05, (now-last)/1000); last=now;

  if(running){
    t += speed*dt*(0.45 + 0.55*Math.sin(now*0.0007+1.2)); // slight pulsation
    if(t>=1){ t=1; running=false; elBadge.style.display=''; elBadge.textContent='ARRIVO: MARTE'; }
  }

  // auto camera tracks ahead on path
  const here = samplePath(t);
  const ahead = samplePath(clamp(t+0.02,0,1));
  // distance remaining to Mars (fake km scale)
  const remaining = Math.max(0, (1-t)*225e6); // km (fittizio)
  const v_kms = clamp(speed*12000, 36, 48000); // km/s (fittizio per HUD)

  if(cam.mode==='AUTO'){
    cam.x = lerp(cam.x, here.x+0.0, 0.06);
    cam.y = lerp(cam.y, here.y+0.25, 0.06);
    cam.z = lerp(cam.z, here.z+0.75, 0.06);
    const dx=ahead.x-here.x, dy=ahead.y-here.y, dz=ahead.z-here.z;
    const targetYaw = Math.atan2(dx,dz);
    const targetPitch = Math.atan2(dy, Math.hypot(dx,dz));
    cam.ry = lerp(cam.ry, targetYaw, 0.06);
    cam.rx = lerp(cam.rx, targetPitch, 0.06);
  } else {
    cam.ry += yawDrag; yawDrag *= 0.9;
    cam.rx = clamp(cam.rx + pitchDrag, -1.0, 1.0); pitchDrag *= 0.9;
    // keep camera following the ship lightly
    cam.x = lerp(cam.x, here.x+0.0, 0.02);
    cam.y = lerp(cam.y, here.y+0.25, 0.02);
    cam.z = lerp(cam.z, here.z+0.95, 0.02);
  }

  // update HUD
  document.getElementById('phase').textContent = phaseFor(t);
  document.getElementById('dist').textContent  = remaining.toLocaleString('it-IT')+' km';
  document.getElementById('vel').textContent   = Math.round(v_kms).toLocaleString('it-IT')+' km/s';
  document.getElementById('prog').style.width  = Math.round(t*100)+'%';

  // draw
  renderScene(here);

  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);

/* ===== Rendering ===== */
function renderScene(here){
  // clear
  ctx.clearRect(0,0,W,H);

  // stars (projected; treat as very far, parallax with camera angles)
  ctx.save();
  for(const s of stars){
    const p = worldToScreen({x:s.x*0.02, y:s.y*0.02, z:50+s.z*0.02}); // push far away
    if(p.x<0||p.x>W||p.y<0||p.y>H) continue;
    const a = 0.35 + s.mag*0.65;
    ctx.globalAlpha = a;
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(p.x, p.y, 1.2, 1.2);
  }
  ctx.restore();

  // trail / trajectory (thin polyline ahead)
  ctx.beginPath();
  for(let i=0;i<=120;i++){
    const tt = clamp(t + i/120*0.22, 0, 1);
    const P = worldToScreen(samplePath(tt));
    if(i===0) ctx.moveTo(P.x,P.y); else ctx.lineTo(P.x,P.y);
  }
  ctx.strokeStyle = 'rgba(77,208,255,.35)';
  ctx.lineWidth = 2;
  ctx.stroke();

  // render planets sorted by depth (far to near)
  const bodies = [];
  for(const wp of WAYPOINTS){
    // make them move a bit (orbiting illusion)
    const wob = 0.15*Math.sin(performance.now()*0.0002 + wp.p.x*1.3);
    const pos = {x:wp.p.x, y:wp.p.y, z:wp.p.z+wob};
    const scr = worldToScreen(pos);
    bodies.push({wp,pos,scr});
  }
  bodies.sort((a,b)=>b.scr.z - a.scr.z);

  const used = new Set();
  for(const b of bodies){
    const [h,s,l] = b.wp.color;
    const hit = drawPlanet(b.pos, b.wp.r, h,s,l, !!b.wp.rings, 0.7);
    if(hit){
      setLabel(b.wp.name, hit.x, hit.y - hit.r*1.05);
      used.add(b.wp.name);
    }
  }
  hideUnusedLabels(used);

  // spacecraft marker at "here"
  const ship = worldToScreen(here);
  if(ship.z>0){
    ctx.beginPath();
    ctx.arc(ship.x, ship.y, Math.max(2, 4*ship.scale*W), 0, TAU);
    ctx.fillStyle = '#9ae6ff';
    ctx.fill();
    // heading line
    const a = Math.atan2( (worldToScreen(samplePath(clamp(t+0.01,0,1))).y - ship.y),
                          (worldToScreen(samplePath(clamp(t+0.01,0,1))).x - ship.x) );
    ctx.beginPath();
    ctx.moveTo(ship.x, ship.y);
    ctx.lineTo(ship.x + Math.cos(a)*30, ship.y + Math.sin(a)*30);
    ctx.strokeStyle = 'rgba(154,224,255,.9)'; ctx.lineWidth = 1.5; ctx.stroke();
  }
}

})();</script>
</body>
</html>
